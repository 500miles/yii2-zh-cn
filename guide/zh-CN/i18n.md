国际化
====================

国际化(I18N)指软件应用设计成无须改动引擎即可应用于不同语言和地区的过程。对于 web 应用，这点特别重要，因为潜在用户是全球范围的。

地区和语言
-------------------

在 Yii 应用中定义了两个语言属性：[[yii\base\Application::$sourceLanguage|source language]]和[[yii\base\Application::$language|target language]]。源语言是应用消息原始编写语言：


```php
echo \Yii::t('app', 'I am a message!');
```

> **提示**：默认是英语，推荐不要更改。原因是人们翻译英语到其他语言比非英语翻译到其他语言更容易。

目标语言是当前使用的语言，在应用配置中如下定义：

```php
// ...
return [
    'id' => 'applicationID',
    'basePath' => dirname(__DIR__),
    'language' => 'ru-RU' // ← 在这里！
```

然后就能容易地实时更改：

```php
\Yii::$app->language = 'zh-CN';
```

格式是 `ll-CC` ，其中 `ll` 是语言的两个或三个小写字母代码，根据[ISO-639](http://www.loc.gov/standards/iso639-2/)分配确定，而 `CC` 是国家代码，根据[ISO-3166](http://www.iso.org/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html)分配确定。

如果没有 `ru-RU` 翻译文件，Yii 将在提示失败前尝试查找 `ru` 翻译文件。

> **注意**：你能更进一步地自定义指定语言的细节[as documented in ICU project](http://userguide.icu-project.org/locale#TOC-The-Locale-Concept).

消息翻译
-------------------

### 基础

Yii 基础消息翻译在基本的变换工作中无须使用其他 PHP 扩展。它要做的只是查找从源语言翻译到目标语言的消息翻译文件。消息以`\Yii::t` 方法的第二个参数来指定：

```php
echo \Yii::t('app', 'This is a string to translate!');
```

Yii 将尝试从定义在 `i18n` 组件配置中的消息源加载适当的翻译：

```php
'components' => [
    // ...
    'i18n' => [
        'translations' => [
            'app*' => [
                'class' => 'yii\i18n\PhpMessageSource',
                //'basePath' => '@app/messages',
                //'sourceLanguage' => 'en',
                'fileMap' => [
                    'app' => 'app.php',
                    'app/error' => 'error.php',
                ],
            ],
        ],
    ],
],
```

以上 `app*` 指定了该消息源处理哪些类别的消息。这个例子中我们处理以 `app`开头的所有消息。你也可以指定缺省翻译，更多消息请参考[i18n 示例](i18n.md#examples).

`class` 定义使用哪个消息源。以下消息源是可用的：

- PhpMessageSource 使用 PHP 文件保存
- GettextMessageSource 使用 GNU Gettext MO 或 PO 文件保存
- DbMessageSource 使用数据库保存

`basePath` 定义当前使用消息源在哪里保存消息。该例中保存在应用的 `messages` 目录。使用数据库保存的情况要跳过这个选项。

`sourceLanguage` 定义 `\Yii::t` 第二个参数使用的语言。如未定义，将使用应用的代码语言。

`fileMap` 在`PhpMessageSource` 使用时定义指定在 `\Yii::t()` 第一个参数的消息类别如何映射到文件。该例中我们定义了两个类别 `app` 和 `app/error` 。

依靠`BasePath/messages/LanguageID/CategoryName.php` 这样约定好的翻译文件格式可省略配置 `fileMap` 。

#### 命名占位符

可以添加参数到翻译消息，翻译后这些参数将被对应的值替换。格式是使用大括号包围参数名，如下所示：

```php
$username = 'Alexander';
echo \Yii::t('app', 'Hello, {username}!', [
    'username' => $username,
]);
```

注意参数赋值没有大括号。

#### Positional placeholders

```php
$sum = 42;
echo \Yii::t('app', 'Balance: {0}', $sum);
```

> **Tip**: Try keep message strings meaningful and avoid using too many positional parameters. Remember that
> translator has source string only so it should be obvious about what will replace each placeholder.

### Advanced placeholder formatting


In order to use advanced features you need to install and enable [intl](http://www.php.net/manual/en/intro.intl.php) PHP
extension. After installing and enabling it you will be able to use extended syntax for placeholders. Either short form
`{placeholderName, argumentType}` that means default setting or full form `{placeholderName, argumentType, argumentStyle}`
that allows you to specify formatting style.

Full reference is [available at ICU website](http://icu-project.org/apiref/icu4c/classMessageFormat.html) but since it's
a bit cryptic we have our own reference below.

#### Numbers

```php
$sum = 42;
echo \Yii::t('app', 'Balance: {0, number}', $sum);
```

You can specify one of the built-in styles (`integer`, `currency`, `percent`):

```php
$sum = 42;
echo \Yii::t('app', 'Balance: {0, number, currency}', $sum);
```

Or specify custom pattern:

```php
$sum = 42;
echo \Yii::t('app', 'Balance: {0, number, ,000,000000}', $sum);
```

[Formatting reference](http://icu-project.org/apiref/icu4c/classicu_1_1DecimalFormat.html).

#### Dates

```php
echo \Yii::t('app', 'Today is {0, date}', time());
```

Built in formats (`short`, `medium`, `long`, `full`):

```php
echo \Yii::t('app', 'Today is {0, date, short}', time());
```

Custom pattern:

```php
echo \Yii::t('app', 'Today is {0, date, YYYY-MM-dd}', time());
```

[Formatting reference](http://icu-project.org/apiref/icu4c/classicu_1_1SimpleDateFormat.html).

#### Time

```php
echo \Yii::t('app', 'It is {0, time}', time());
```

Built in formats (`short`, `medium`, `long`, `full`):

```php
echo \Yii::t('app', 'It is {0, time, short}', time());
```

Custom pattern:

```php
echo \Yii::t('app', 'It is {0, date, HH:mm}', time());
```

[Formatting reference](http://icu-project.org/apiref/icu4c/classicu_1_1SimpleDateFormat.html).


#### Spellout

```php
echo \Yii::t('app', '{n,number} is spelled as {n, spellout}', ['n' => 42]);
```

#### Ordinal

```php
echo \Yii::t('app', 'You are {n, ordinal} visitor here!', ['n' => 42]);
```

Will produce "You are 42nd visitor here!".

#### Duration


```php
echo \Yii::t('app', 'You are here for {n, duration} already!', ['n' => 47]);
```

Will produce "You are here for 47 sec. already!".

#### Plurals

Different languages have different ways to inflect plurals. Some rules are very complex so it's very handy that this
functionality is provided without the need to specify inflection rule. Instead it only requires your input of inflected
word in certain situations.

```php
echo \Yii::t('app', 'There {n, plural, =0{are no cats} =1{is one cat} other{are # cats}}!', ['n' => 0]);
```

Will give us "There are no cats!".

In the plural rule arguments above `=0` means exactly zero, `=1` stands for exactly one `other` is for any other number.
`#` is replaced with the `n` argument value. It's not that simple for languages other than English. Here's an example
for Russian:

```
Здесь {n, plural, =0{котов нет} =1{есть один кот} one{# кот} few{# кота} many{# котов} other{# кота}}!
```

In the above it worth mentioning that `=1` matches exactly `n = 1` while `one` matches `21` or `101`.

Note that if you are using placeholder twice and one time it's used as plural another one should be used as number else
you'll get "Inconsistent types declared for an argument: U_ARGUMENT_TYPE_MISMATCH" error:

```
Total {count, number} {count, plural, one{item} other{items}}.
```

To learn which inflection forms you should specify for your language you can referrer to
[rules reference at unicode.org](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html).

#### Selections

You can select phrases based on keywords. The pattern in this case specifies how to map keywords to phrases and
provides a default phrase.

```php
echo \Yii::t('app', '{name} is {gender} and {gender, select, female{she} male{he} other{it}} loves Yii!', [
    'name' => 'Snoopy',
    'gender' => 'dog',
]);
```

Will produce "Snoopy is dog and it loves Yii!".

In the expression `female` and `male` are possible values. `other` handler values that do not match. Strings inside
brackets are sub-expressions so could be just a string or a string with more placeholders.

### Specifying default translation

You can specify default translation that will be used as a fallback for categories that don't match any other translation.
This translation should be marked with `*`. In order to do it add the following to the config file (for the `yii2-basic` application it will be `web.php`):

```php
//configure i18n component

'i18n' => [
    'translations' => [
        '*' => [
            'class' => 'yii\i18n\PhpMessageSource'
        ],
    ],
],
```

Now you can use categories without configuring each one that is similar to Yii 1.1 behavior.
Messages for the category will be loaded from a file under default translation `basePath` that is `@app/messages`:

```php
echo Yii::t('not_specified_category', 'message from unspecified category');
```

Message will be loaded from `@app/messages/<LanguageCode>/not_specified_category.php`.

### Translating module messages

If you want to translate messages for a module and avoid using a single translation file for all messages, you can make it like the following:

```php
<?php

namespace app\modules\users;

use Yii;

class Module extends \yii\base\Module
{
    public $controllerNamespace = 'app\modules\users\controllers';

    public function init()
    {
        parent::init();
        $this->registerTranslations();
    }

    public function registerTranslations()
    {
        Yii::$app->i18n->translations['modules/users/*'] = [
            'class' => 'yii\i18n\PhpMessageSource',
            'sourceLanguage' => 'en',
            'basePath' => '@app/modules/users/messages',
            'fileMap' => [
                'modules/users/validation' => 'validation.php',
                'modules/users/form' => 'form.php',
                ...
            ],
        ];
    }

    public static function t($category, $message, $params = [], $language = null)
    {
        return Yii::t('modules/users/' . $category, $message, $params, $language);
    }

}
```

In the example above we are using wildcard for matching and then filtering each category per needed file. Instead of using `fileMap` you can simply
use convention of category mapping to the same named file and use `Module::t('validation', 'your custom validation message')` or `Module::t('form', 'some form label')` directly.

### Translating widgets messages

Same rules can be applied for widgets too, for example:

```php
<?php

namespace app\widgets\menu;

use yii\base\Widget;
use Yii;

class Menu extends Widget
{

    public function init()
    {
        parent::init();
        $this->registerTranslations();
    }

    public function registerTranslations()
    {
        $i18n = Yii::$app->i18n;
        $i18n->translations['widgets/menu/*'] = [
            'class' => 'yii\i18n\PhpMessageSource',
            'sourceLanguage' => 'en',
            'basePath' => '@app/widgets/menu/messages',
            'fileMap' => [
                'widgets/menu/messages' => 'messages.php',
            ],
        ];
    }

    public function run()
    {
        echo $this->render('index');
    }

    public static function t($category, $message, $params = [], $language = null)
    {
        return Yii::t('widgets/menu/' . $category, $message, $params, $language);
    }

}
```

Instead of using `fileMap` you can simply use convention of category mapping to the same named file and use `Menu::t('messages', 'new messages {messages}', ['{messages}' => 10])` directly.

> **Note**: For widgets you also can use i18n views, same rules as for controllers are applied to them too.


### Translating framework messages

Sometimes you want to correct default framework message translation for your application. In order to do so configure
`i18n` component like the following:

```php
'components' => [
    'i18n' => [
        'translations' => [
            'yii' => [
                'class' => 'yii\i18n\PhpMessageSource',
                'sourceLanguage' => 'en',
                'basePath' => '/path/to/my/message/files'
            ],
        ],
    ],
],
```

Now you can place your adjusted translations to `/path/to/my/message/files`.

Views
-----

You can use i18n in your views to provide support for different languages. For example, if you have view `views/site/index.php` and
you want to create special case for russian language, you create `ru-RU` folder under the view path of current controller/widget and
put there file for russian language as follows `views/site/ru-RU/index.php`.

> **Note**: If language is specified as `en-US` and there are no corresponding views, Yii will try views under `en`
> before using original ones.

i18n formatter
--------------

i18n formatter component is the localized version of formatter that supports formatting of date, time and numbers based
on current locale. In order to use it you need to configure formatter application component as follows:

```php
return [
    // ...
    'components' => [
        'formatter' => [
            'class' => 'yii\i18n\Formatter',
        ],
    ],
];
```

After cofiguring the component can be accessed as `Yii::$app->formatter`.

Note that in order to use i18n formatter you need to install and enable
[intl](http://www.php.net/manual/en/intro.intl.php) PHP extension.

In order to learn about formatter methods refer to its API documentation: [[yii\i18n\Formatter]].
